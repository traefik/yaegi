package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"net/http"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"
)

//go:generate go run . --name main --path schema.go --patch patch.json --url http://json-schema.org/draft-04/schema#

func fatalf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}

var schemaUrl = flag.String("url", "", "URL of the schema")
var packageName = flag.String("name", "", "Package name")
var filePath = flag.String("path", "", "File to write to")
var jsonPatch = flag.String("patch", "", "JSON file to apply as a patch")

func main() {
	flag.Parse()

	if *schemaUrl == "" {
		fatalf("--url is required")
	}
	if *packageName == "" {
		fatalf("--name is required")
	}
	if *filePath == "" {
		fatalf("--path is required")
	}

	resp, err := http.Get(*schemaUrl)
	if err != nil {
		fatalf("http: %v\n", err)
	}

	if resp.StatusCode != 200 {
		resp.Body.Close()
		fatalf("http: expected status 200, got %d\n", resp.StatusCode)
	}

	b, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		fatalf("json: %v\n", err)
	}

	var schema Schema
	err = json.Unmarshal(b, &schema)
	if err != nil {
		fatalf("json: %v\n", err)
	}

	if *jsonPatch != "" {
		b, err := os.ReadFile(*jsonPatch)
		if err != nil {
			fatalf("json: %v\n", err)
		}

		err = json.Unmarshal(b, &schema)
		if err != nil {
			fatalf("json: %v\n", err)
		}
	}

	buf := new(bytes.Buffer)
	(&writer{
		Writer:    buf,
		schema:    &schema,
		name:      "Schema",
		seen:      map[*Schema]string{},
		seenPlain: map[SimpleTypes]string{},
	}).writeFile(*packageName)

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *filePath, buf, parser.ParseComments)
	if err != nil {
		fatalf("json: %v\n", err)
	}

	f, err := os.Create(*filePath)
	if err != nil {
		fatalf("json: %v\n", err)
	}
	defer f.Close()

	err = format.Node(f, fset, file)
	if err != nil {
		fatalf("json: %v\n", err)
	}
}

type writer struct {
	io.Writer
	schema    *Schema
	name      string
	seen      map[*Schema]string
	seenPlain map[SimpleTypes]string
}

func forEachOrdered(m map[string]*Schema, fn func(string, *Schema)) {
	names := make([]string, 0, len(m))
	for name := range m {
		names = append(names, name)
	}

	sort.StringSlice(names).Sort()

	for _, name := range names {
		fn(name, m[name])
	}
}

func (w *writer) writeFile(packageName string) {
	fmt.Fprintf(w, "package %s\n", packageName)
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "// Code generated by 'go run ../internal/cmd/json_schema'. DO NOT EDIT.\n")
	fmt.Fprintf(w, "\n")

	forEachOrdered(w.schema.Definitions, func(name string, s *Schema) {
		w.writeSchema(name, s)
	})

	if w.schema.Properties != nil {
		w.writeSchema(w.name, w.schema)
	}
}

func (w *writer) writeSchema(name string, s *Schema) (typ string) {
	if typ := w.seen[s]; typ != "" {
		return typ
	}
	defer func() { w.seen[s] = typ }()

	if s.PatternProperties != nil {
		fatalf("type %q: pattern properties are not supported\n", name)
	}

	if s.Ref != "" {
		if !isPlain(s) {
			fatalf("type %q: non-plain ref types are not supported\n", name)
		}
		return w.writeRef(s.Ref)
	}

	if s.Type != nil && s.Enum == nil {
		return w.writeType(name, s)
	}

	if isPlain(s) {
		return "interface{}"
	}

	if howMany(s.Enum, s.AllOf, s.AnyOf, s.OneOf, s.Not) > 1 {
		fatalf("type %q: enum, allOf, anyOf, oneOf, and not cannot be used together\n", name)
	}

	if s.AllOf != nil {
		return w.writeAllOf(name, s.AllOf)
	}

	if s.AnyOf != nil {
		fmt.Fprintf(os.Stderr, "type %q: anyOf not supported, using interface{}\n", name)
		return "interface{}"
	}

	if s.OneOf != nil {
		fmt.Fprintf(os.Stderr, "type %q: oneOf not supported, using interface{}\n", name)
		return "interface{}"
	}

	if s.Not != nil {
		fmt.Fprintf(os.Stderr, "type %q: not not supported, using interface{}\n", name)
		return "interface{}"
	}

	if s.Enum != nil {
		return w.writeEnum(name, s.Enum)
	}

	fmt.Fprintf(os.Stderr, "type %q: unsupported schema\n", name)
	enc := json.NewEncoder(os.Stderr)
	enc.SetIndent("", "    ")
	enc.Encode(s)
	os.Exit(1)
	panic("not reachable")
}

func howMany(v ...interface{}) int {
	c := 0
	for _, v := range v {
		if v != nil && !reflect.ValueOf(v).IsNil() {
			c++
		}
	}
	return c
}

func resolveRef(s *Schema, ref string) (string, *Schema) {
	if ref == "#" {
		return "", s
	}

	const schemaDefs = "#/definitions/"
	if strings.HasPrefix(ref, schemaDefs) {
		name := ref[len(schemaDefs):]
		s, ok := s.Definitions[name]
		if !ok {
			fatalf("missing definition for %q\n", name)
		}
		return name, s
	}

	fatalf("unsupported ref %q\n", ref)
	panic("not reachable")
}

func (w *writer) writeRef(ref string) string {
	if len(ref) == 0 {
		fatalf("empty ref")
	}

	if ref[0] == '!' {
		return ref[1:]
	}

	name, s := resolveRef(w.schema, ref)
	if name == "" {
		return w.writeSchema(w.name, s)
	}

	return w.writeSchema(strings.ToUpper(name[:1])+name[1:], s)
}

func (w *writer) writeType(name string, s *Schema) string {
	if len(s.Type) == 0 {
		// this is not actually valid according to the schema
		return "interface{}"
	}

	if isPlain(s) {
		if len(s.Type) > 1 {
			return "interface{}"
		}
		return w.writePlainType(s.Type[0])
	}

	if len(s.Type) > 1 {
		fatalf("type %q: unsupported: multiple types", name)
	}

	switch s.Type[0] {
	case SimpleTypes_Object:
		return w.writeObjectType(name, s)

	case SimpleTypes_Array:
		if s.AdditionalItems != nil {
			fatalf("type %q: additionalItems not supported\n", name)
		}
		return "[]" + w.writeSchema(name+"__Items", s.Items)

	case SimpleTypes_Boolean:
		if isPlainExceptDefault(s) && s.Default == false {
			return w.writePlainType("boolean")
		}

	case SimpleTypes_Integer:
		if isPlainExceptDefault(s) && s.Default == float64(0) {
			return w.writePlainType("integer")
		}

	case SimpleTypes_Number:
		if isPlainExceptDefault(s) && s.Default == float64(0) {
			return w.writePlainType("number")
		}

	case SimpleTypes_String:
		if isPlainExceptDefault(s) && s.Default == "" {
			return w.writePlainType("string")
		}
	}

	fmt.Fprintf(os.Stderr, "type %q: unsupported schema\n", name)
	enc := json.NewEncoder(os.Stderr)
	enc.SetIndent("", "    ")
	enc.Encode(s)
	os.Exit(1)
	panic("not reachable")
}

func (w *writer) writePlainType(name SimpleTypes) (typ string) {
	if typ := w.seenPlain[name]; typ != "" {
		return typ
	}
	defer func() { w.seenPlain[name] = typ }()

	switch name {
	case SimpleTypes_Object:
		return "map[string]interface{}"

	case SimpleTypes_Array:
		return "[]interface{}"

	case SimpleTypes_Boolean:
		return "bool"

	case SimpleTypes_Integer:
		return "int"

	case SimpleTypes_Number:
		return "float64"

	case SimpleTypes_String:
		return "string"

	default:
		panic(fmt.Sprintf("unsupported plain type %q", name))
	}
}

func (w *writer) writeObjectType(name string, s *Schema) string {
	if m, ok := s.Default.(map[string]interface{}); ok && len(m) == 0 {
		// ok
	} else if s.Default != nil {
		fatalf("type %s: unsupported default: %v\n", name, s.Default)
	}

	var typ string
	if s.AdditionalProperties == nil {
		typ = "*" + name
		w.seen[s] = typ

		w.writeProperties(name, s)
		fmt.Fprintf(w, "\n")
		return typ
	} else if s.Properties == nil {
		return "map[string]" + w.writeSchema(name+"__Values", s.AdditionalProperties)
	} else {
		// TODO this needs a custom un/marshaller
		fatalf("type %q: unsupported schema: properties and additionalProperties both defined", name)
		panic("not reached")
	}
}

func (w *writer) writeProperties(name string, s *Schema) {
	type Field struct{ Name, Prop, Type string }
	fields := []Field{}
	for prop, s := range s.Properties {
		var f Field
		f.Prop = prop
		if prop[0] == '$' {
			prop = prop[1:]
		}
		if r, size := utf8.DecodeRuneInString(prop); unicode.IsLetter(r) {
			f.Name = string(unicode.ToUpper(r)) + prop[size:]
		} else {
			f.Name = "F" + prop
		}
		f.Type = w.writeSchema(name+"_"+f.Name, s)
		fields = append(fields, f)
	}

	sort.Slice(fields, func(i, j int) bool { return fields[i].Name < fields[j].Name })

	fmt.Fprintf(w, "type %s struct {\n", name)
	for _, f := range fields {
		fmt.Fprintf(w, "\t%s %s `json:\"%s,omitempty\"`\n", f.Name, f.Type, f.Prop)
	}
	fmt.Fprintf(w, "}\n")
}

func (w *writer) replaceField(name string, s, r *Schema, field string) {
	rf := reflect.ValueOf(r).Elem().FieldByName(field)
	rv := rf.Interface()
	if rf.IsNil() {
		return
	}

	sf := reflect.ValueOf(s).Elem().FieldByName(field)
	sv := sf.Interface()
	if sf.IsNil() {
		if _, ok := sv.(map[string]*Schema); ok {
			sv = map[string]*Schema{}
			sf.Set(reflect.ValueOf(sv))
		} else {
			sf.Set(rf)
			return
		}
	}

	switch sv := sv.(type) {
	case Schema_Type:
		m := map[SimpleTypes]bool{}
		for _, v := range rv.(Schema_Type) {
			m[v] = true
		}
		nv := Schema_Type{}
		for _, v := range sv {
			if m[v] {
				nv = append(nv, v)
			}
		}
		sf.Set(reflect.ValueOf(nv))

	case map[string]*Schema:
		for k, v := range rv.(map[string]*Schema) {
			if sv[k] == nil {
				sv[k] = v
			} else {
				w.mergeSchemas(name+"["+k+"]", sv[k], []*Schema{v})
			}
		}

	default:
		if !reflect.DeepEqual(sv, rv) && field != "Enum" {
			fatalf("type %q: unsupported operation: attempting to overwrite field %s\n", name, field)
		}
	}
}

func (w *writer) mergeSchemas(name string, s *Schema, allOf []*Schema) {
	for i, r := range allOf {
		if r.Ref != "" {
			if !isPlain(r) {
				fatalf("type %q: non-plain ref types are not supported\n", name)
			}
			_, r = resolveRef(w.schema, r.Ref)
		}

		if r.AllOf != nil {
			s := new(Schema)
			w.mergeSchemas(fmt.Sprintf("%s[%d]", name, i), s, r.AllOf)
			r = s
		}

		if s.Description == "" {
			s.Description = r.Description
		} else {
			s.Description += "\n" + r.Description
		}

		w.replaceField(name, s, r, "Default")
		w.replaceField(name, s, r, "AdditionalProperties")
		w.replaceField(name, s, r, "Definitions")
		w.replaceField(name, s, r, "Properties")
		w.replaceField(name, s, r, "PatternProperties")
		w.replaceField(name, s, r, "Enum")
		w.replaceField(name, s, r, "Type")
		w.replaceField(name, s, r, "AllOf")
		w.replaceField(name, s, r, "AnyOf")
		w.replaceField(name, s, r, "OneOf")
		w.replaceField(name, s, r, "Not")
	}
}

func (w *writer) writeAllOf(name string, allOf []*Schema) string {
	s := new(Schema)
	w.mergeSchemas(name, s, allOf)
	return w.writeSchema(name, s)
}

func (w *writer) writeEnum(name string, values []string) string {
	name = strings.ToUpper(name[:1]) + name[1:]
	fmt.Fprintf(w, "type %s string\n", name)
	for _, v := range values {
		fmt.Fprintf(w, "const %s_%s%s %s = %q\n", name, strings.ToUpper(v[:1]), v[1:], name, v)
	}
	fmt.Fprintf(w, "\n")
	return name
}

func isPlain(s *Schema) bool {
	return s.Default == nil && isPlainExceptDefault(s)
}

func isPlainExceptDefault(s *Schema) bool {
	return true &&
		s.Items == nil &&
		s.AdditionalProperties == nil &&
		s.Definitions == nil &&
		s.Properties == nil &&
		s.PatternProperties == nil &&
		s.Enum == nil &&
		s.AllOf == nil &&
		s.AnyOf == nil &&
		s.OneOf == nil &&
		s.Not == nil
}

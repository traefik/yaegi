package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"sort"
	"strings"

	"github.com/traefik/yaegi/internal/jsonx"
)

var (
	schemaURL   = flag.String("url", "", "URL of the schema")
	packageName = flag.String("name", "", "Package name")
	filePath    = flag.String("path", "", "File to write to")
	jsonPatch   = flag.String("patch", "", "JSON file to apply as a patch")
)

func fatalf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}

func noerr(fn func() error, msg string, args ...interface{}) {
	err := fn()
	if err != nil {
		fatalf(msg, append(args, err))
	}
}

func main() {
	flag.Parse()

	if *schemaURL == "" {
		fatalf("--url is required")
	}
	if *packageName == "" {
		fatalf("--name is required")
	}
	if *filePath == "" {
		fatalf("--path is required")
	}

	resp, err := http.Get(*schemaURL) //nolint:bodyclose,noctx // It is closed; context is not relevant
	if err != nil {
		fatalf("http: %v\n", err)
	}

	if resp.StatusCode != 200 {
		noerr(resp.Body.Close, "failed to close response body: %v")
		fatalf("http: expected status 200, got %d\n", resp.StatusCode)
	}

	b, err := ioutil.ReadAll(resp.Body)
	noerr(resp.Body.Close, "failed to close response body: %v")
	if err != nil {
		fatalf("read (schema): %v\n", err)
	}

	if *jsonPatch != "" {
		b, err = jsonx.ApplyPatch(b, *jsonPatch)
		if err != nil {
			fatalf("%v\n", err)
		}
	}

	var schema jsonx.Schema
	err = json.Unmarshal(b, &schema)
	if err != nil {
		fatalf("json (schema): %v\n", err)
	}

	var requests, responses, events, missing dapTypes
	for name, s := range schema.Definitions {
		if len(s.AllOf) != 2 || s.AllOf[0].Ref == "" {
			continue
		}

		switch s.AllOf[0].Ref {
		case "#/definitions/Request":
			cmd := s.AllOf[1].Properties["command"]
			if cmd == nil || len(cmd.Enum) != 1 {
				continue
			}

			typ := dapType{
				Identifier: cmd.Enum[0],
				Name:       name[:len(name)-len("Request")] + "Arguments",
			}
			switch {
			case schema.Definitions[typ.Name] != nil:
				// ok
			case schema.Definitions[name+"Arguments"] != nil:
				typ.Name = name + "Arguments"
			default:
				missing = append(missing, typ)
			}

			requests = append(requests, typ)

		case "#/definitions/Response":
			id := name[:len(name)-len("Response")]
			id = strings.ToLower(id[:1]) + id[1:]
			typ := dapType{
				Identifier: id,
				Name:       name + "Body",
			}

			switch {
			case schema.Definitions[typ.Name] != nil:
				// ok
			case id == "initialize" && schema.Definitions["Capabilities"] != nil:
				typ.Name = "Capabilities"
			default:
				missing = append(missing, typ)
			}

			responses = append(responses, typ)

		case "#/definitions/Event":
			evt := s.AllOf[1].Properties["event"]
			if evt == nil || len(evt.Enum) != 1 {
				continue
			}
			typ := dapType{
				Identifier: evt.Enum[0],
				Name:       name + "Body",
			}

			if schema.Definitions[typ.Name] == nil {
				missing = append(missing, typ)
			}

			events = append(events, typ)
		}
	}

	requests.Sort()
	responses.Sort()
	events.Sort()
	missing.Sort()

	w := new(bytes.Buffer)
	fmt.Fprintf(w, "package %s\n", *packageName)
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "// Code generated by 'go run ../internal/cmd/gendap'. DO NOT EDIT.\n")
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "import \"fmt\"\n")
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "type RequestArguments interface{ requestType() string }\n")
	fmt.Fprintf(w, "type ResponseBody interface{ responseType() string }\n")
	fmt.Fprintf(w, "type EventBody interface{ eventType() string }\n")
	fmt.Fprintf(w, "\n")

	requests.writeFuncs(w, "requestType")
	responses.writeFuncs(w, "responseType")
	events.writeFuncs(w, "eventType")
	missing.writeTypes(w)

	requests.writeConstructor(w, "newRequest", "RequestArguments", "unrecognized command %q")
	responses.writeConstructor(w, "newResponse", "ResponseBody", "unrecognized command %q")
	events.writeConstructor(w, "newEvent", "EventBody", "unrecognized event %q")

	f, err := os.Create(*filePath)
	if err != nil {
		fatalf("json: %v\n", err)
	}
	defer noerr(f.Close, "failed to close %s: %v", *filePath)

	// w.WriteTo(f)

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *filePath, w, parser.ParseComments)
	if err != nil {
		fatalf("json: %v\n", err)
	}

	err = format.Node(f, fset, file)
	if err != nil {
		fatalf("json: %v\n", err)
	}
}

type dapType struct {
	Name, Identifier string
}

type dapTypes []dapType

func (t dapTypes) Less(i, j int) bool { return t[i].Name < t[j].Name }
func (t dapTypes) Sort()              { sort.Slice(t, t.Less) }

func (t dapTypes) writeFuncs(w io.Writer, name string) {
	for _, t := range t {
		fmt.Fprintf(w, "func (*%s) %s() string { return %q }\n", t.Name, name, t.Identifier)
	}
	fmt.Fprintf(w, "\n")
}

func (t dapTypes) writeTypes(w io.Writer) {
	for _, t := range t {
		fmt.Fprintf(w, "type %s struct{}\n", t.Name)
	}
	fmt.Fprintf(w, "\n")
}

func (t dapTypes) writeConstructor(w io.Writer, name, typ, err string) {
	fmt.Fprintf(w, "func %s(x string) (%s, error) {\n", name, typ)
	fmt.Fprintf(w, "\tswitch x {\n")
	for _, t := range t {
		fmt.Fprintf(w, "\tcase %q:\n", t.Identifier)
		fmt.Fprintf(w, "\t\treturn new(%s), nil\n", t.Name)
	}
	fmt.Fprintf(w, "\tdefault:\n")
	fmt.Fprintf(w, "\t\treturn nil, fmt.Errorf(%q, x)\n", err)
	fmt.Fprintf(w, "\t}\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")
}
